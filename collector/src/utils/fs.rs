use anyhow::Context;
use std::ffi::OsStr;
use std::fs;
use std::path::{Component, Path};

#[cfg(windows)]
pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> anyhow::Result<()> {
    let (from, to) = (from.as_ref(), to.as_ref());

    let ctx = format!("renaming file {:?} to {:?}", from, to);

    if fs::metadata(from)?.is_file() {
        return Ok(fs::rename(from, to).with_context(|| ctx.clone())?);
    }

    robocopy(from, to, &[&"/move"]).with_context(|| ctx.clone())
}

/// Touch a file, resetting its modification time.
pub fn touch(path: &Path) -> anyhow::Result<()> {
    log::trace!("touching file {:?}", path);

    filetime::set_file_mtime(path, filetime::FileTime::now())
        .with_context(|| format!("touching file {:?}", path))?;

    Ok(())
}

/// Reset the modification time of all files in the given path.
pub fn touch_all(path: &Path) -> anyhow::Result<()> {
    fn is_valid(path: &Path) -> bool {
        let target_dir = Component::Normal(OsStr::new("target"));

        // Don't touch files in `target/`, since they're likely generated by build scripts and might be from a dependency.
        if path.components().any(|component| component == target_dir) {
            return false;
        }

        if let Some(extn) = path.extension() {
            if extn.to_str() == Some("rs") {
                // Don't touch build scripts, which confuses the wrapped rustc.
                return path.file_name() != Some(OsStr::new("build.rs"));
            }
        }

        false
    }

    for entry in walkdir::WalkDir::new(path) {
        let entry = entry?;
        let path = entry.path();

        // We also delete the cmake caches to avoid errors when moving directories around.
        // This might be a bit slower but at least things build
        if path.file_name() == Some(OsStr::new("CMakeCache.txt")) {
            fs::remove_file(path)
                .with_context(|| format!("deleting cmake caches in {:?}", path))?;
        }

        if is_valid(path) {
            touch(path)?;
        }
    }

    Ok(())
}

#[cfg(windows)]
pub fn robocopy(
    from: &std::path::Path,
    to: &std::path::Path,
    extra_args: &[&dyn AsRef<std::ffi::OsStr>],
) -> anyhow::Result<()> {
    use crate::utils::command::run_command_with_output;

    let mut cmd = Command::new("robocopy");
    cmd.arg(from).arg(to).arg("/s").arg("/e");

    for arg in extra_args {
        cmd.arg(arg.as_ref());
    }

    let output = run_command_with_output(&mut cmd)?;

    if output.status.code() >= Some(8) {
        // robocopy returns 0-7 on success
        return Err(anyhow::anyhow!(
            "expected success, got {}\n\nstderr={}\n\n stdout={}",
            output.status,
            String::from_utf8_lossy(&output.stderr),
            String::from_utf8_lossy(&output.stdout)
        ));
    }

    Ok(())
}
